import { split, trim } from "std/text"
import { env_var_get } from "std/env"
import { dir_create, file_exists, file_write } from "std/fs"

// Load environment variables
const amber_path = trust env_var_get("AMBER_SCRIPT_AMBER_PATH")
const cache_path_input = trust env_var_get("AMBER_SCRIPT_CACHE_PATH_INPUT")
const script_content = trust env_var_get("AMBER_SCRIPT_CONTENT")
const script_hash = trust env_var_get("AMBER_SCRIPT_HASH")

main {
  // Calculate cache path
  const amber_cache_path = trim(cache_path_input) == ""
    then "{trust env_var_get("HOME")}/.cache/amber-script-action"
    else cache_path_input

  const dist_path = "{amber_cache_path}/dist/{script_hash}.sh"
  const outputs_path = "{amber_cache_path}/outputs/{script_hash}.txt"

  // Build the given script
  if file_exists(dist_path) {
    echo "::debug::A compiled bash script found. Skip building."
  } else {
    dir_create("{amber_cache_path}/tmp")?
    file_write("{amber_cache_path}/tmp/{script_hash}.ab", script_content)?
    dir_create("{amber_cache_path}/dist")?

    $ "{amber_path}" build "{amber_cache_path}/tmp/{script_hash}.ab" "{dist_path}" $ failed(code) {
      echo "Failed to build script with exit code {code}"
      exit code
    }
  }

  // Prepare outputs collection
  dir_create("{amber_cache_path}/outputs")?
  $ touch {outputs_path} $?
  $ AMBER_SCRIPT_OUTPUT="{outputs_path}" $?
  $ export AMBER_SCRIPT_OUTPUT $?

  // Run the compiled script
  $ bash "{dist_path}" $?

  // Process outputs into JSON and write to GITHUB_OUTPUT
  const json_output = $ jq -R -s -c 'split("\n") | map(select(length > 0)) | map(split("=")) | map(\{(.[0]): .[1]}) | add // \{}' "{outputs_path}" $ failed {
    echo "::warning::Failed to process outputs, using empty object"
    echo "\{\}"
  }
  $ echo "script_outputs={json_output}" >> \$GITHUB_OUTPUT $ failed(code) {
    echo "::warning::Failed to set script_outputs with code {code}"
  }
}
